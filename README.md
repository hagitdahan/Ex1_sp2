# תכנות מערכות 2 מטלה מספר 1
הפעלה:
'make' לקמפל את התוכנית ולהריץ demo
'make test' קמפול הטסטים
'./test' הרצת הטסטים 



1.	בכל הרצת אלגוריתם צריך להריץ קודם את loadgraph()
2.	גרף לא מכוון U------V לא נחשב מעגל, גרף מכוון U------>V V------->U נחשב מעגל רק אם משקלי הצלעות שונה אחרת זהו גרף מכוון
3.	גרף לא מכוון = גרף סימטרי עבורי בבדיקות
4.	בבדיקות שלי אין צלע מקודקוד לעצמו




Graph.cpp 
// מחלקה המייצגת גרף בונה אותו מאתחלת את המשתנים ומדפיסה אותו

Funcions:

`Graph::Graph()` :  מאתחלת את הגרף עם ערכים ברירת מחדל
numOfVertices(0)- כמות קודקודים שווה ל-0 בהתחלה
numEdges(0)- כמות צלעות בהתחלה שווה לאפס
adjancencyMatrix()- מטריצת השכנויות המייצגת את הגרף
graphType(GraphType::UNDIRECTED)- מאתחלת את תכונת הגרף המכוון כדיפולא לא מכוון
weightType(WeightType::UNWEIGHTED)- מאתחלת את הגרף כלא ממשוקל באופן דיפולטיבי
edgeType(EdgeType::NON_NEGATIVE)- מאתחלת את תכונת המאפשרת משקלים שליליים כלא מאפשרת


`void Graph::loadGraph(const vector<vector<int>> &matrix);` :  טוען את הגרף ממטריצת שכנות שמועברת כפרמטר בצורת מטריצה דו-מימדית. פונקציה זו מאתחלת את מטריצת השכנויות של הגרף ומעדכנת את מספר הקודקודים והצלעות בהתאם.

`void Graph::printGraph();`: מדפיסה את מטריצת השכנויות 

Help Funcion:

`bool Graph::isValid(const vector<vector<int>>& matrix);`: פונקצייה הבודקת האם המטריצה שהתקבלה ריבועית אחרת מחזיר שגיאה


Algorithms.cpp:
// מחלקה המייצגת את כל האלגוריתמים אשר נדרשתי לממש ועוד פונקציות עזר


`void Algorithms::dfs(Graph &g, int vertex, vector<bool> &visited);`: פונקצייה המבצעת חיפוש לעומק (DFS) על הגרף החל מהקודקוד שהתקבל ומסמן את הקודקודים שנסרקו בוקטור visited 

`bool Algorithms::isConnected(Graph &g);` :
אופן המימוש הוא הרצת אלגוריתם DFS מכל קודקוד אם יש קודקוד מסויים שלא ניתן להגיע אליו מקודקוד אחר מחזירים שהגרף לא קשיר חזק אחרת נחזיר שכן


//פונקציה זזו מקבלת גרף, קודקוד התחלה וסוף אם בגרף יש משקלים שליליים אנינעזרת בפונקציית עזר ממחלקת BellmanFord אשר מחשבת לי את המסלול הקצר ואם אין משקלים שליליים בגרף אני משתמשת בפונקציית עזר ממחלקת Dijkstra 

לבסוף עבור הפלט שמוחזר לי אני מחזירה את המסלול הקצר ביותר אם קיים אחרת מחזירה -1
`string Algorithms::shortestPath(Graph& g, int source, int destination);`

//פונקצית עזר אשר בעזרת הרצת DFS שצובע את הקודקודים באפור כאשר הגענו אליהם ואז במידה והגעתי לקודקוד מסויים שצבעו אפור כבר אני יודעת שנסגר מעגל
`string Algorithms::dfsForCycle(int vertex, vector<vector<int>>& graph, vector<string>& colors, vector<int>& parent,vector<int>&visited,GraphType type);`

//אשר בודקת עבור השכנים של אותו קודקוד אם מישהו ביקר אצלםdfsForCycle פונקצייה זו מריצה עבור כל קוקוד את הפונקציית עזר 
`string Algorithms::isContainsCycle(Graph& g);`

//פונקצייה זו משתמשת באלגוריתם שלמדנו בתרגול אלגוריתמים 1 שעובדת בצורה הבאה :
 מתחילה מקודקוד ראשון כלשהו וצובעת אותו בכחול עבור כל השכנים שלו היא תצבע אותם בצבע ההופכי שלו במידה והוא פגש כבר שכן שצבעו זהה לשלו הפונקצייה תחזיר שהוא לא דו צדדי אחרת כן
`string Algorithms::isBipartite(Graph& g);`

//פונקצייה זו נעזרת בפונקציית עזר ממחלקת BellmanFord 
אשר מריצה את האלגוריתם של בלמן עם תוספת של מציאת המעגל 
`string Algorithms::negativeCycle(Graph& g);`


BellmanFord.cpp
זוהי מחלקה שמבצעת את אלגוריתם בלמן פורד על מנת למצוא מסלול קצר או מעגל בגרפים עם משקלים שליליים 

Fuctions:

//פונקציה זו מריצה DFS ראשית כדי לדעת לאיזה קודקודים ניתן להגיע מקודקוד ההתחלה לאחר מכן נעזרת בפלט של פונקציה זו ומשתמשת בוקטור אב שאותו היא מעדכנת בכל פעם שהתבצע רילקס כלומר נמצא מסלול קצר יותר את התהליך הזה אני עושה V-1 פעמים ואם קרה עדכון בפעם הV אני לא מחזירה מסלול אחרת אני מחזירה מסלול לפי וקטור האבות
`vector<int> BellmanFord::ShortestPathB(Graph &g, int start, int end);`


//פונקציה זו מריצה רילקס על הקודקודים V-1 פעמים ולפי הפעם הV תדע האם יש מעגל או שמה יש מסלול קצר ביותר 
`vector<int> BellmanFord::findNegativeCycle(Graph& g);`

Dijkstra.cpp

Function:

//שימוש באלגויתם דייקסטרה אשר מוצא את המסלול הקצר ביותר מקודקוד לאחר במידה וקיים אחרת מחזיר מסלול ריק
`static string shortestPathDijkstra(Graph& g, int source, int destination);`